<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Redstone Lab 2D - Professional Edition</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    body {
      background-color: #050505;
      color: #e2e8f0;
      margin: 0;
      font-family: 'VT323', monospace;
      overflow: hidden;
    }
    .custom-scroll::-webkit-scrollbar { width: 6px; }
    .custom-scroll::-webkit-scrollbar-track { background: #111; }
    .custom-scroll::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
    
    .grid-bg {
      background-image: linear-gradient(#1a1a1a 1px, transparent 1px),
                        linear-gradient(90deg, #1a1a1a 1px, transparent 1px);
      background-size: 40px 40px;
    }

    .redstone-glow {
      filter: drop-shadow(0 0 4px rgba(255, 0, 0, 0.6));
    }
    
    .pixelated {
      image-rendering: pixelated;
    }

    /* Tool animations */
    .btn-active {
      transform: scale(0.95);
      box-shadow: inset 0 0 10px rgba(239, 68, 68, 0.4);
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "@google/genai": "https://esm.sh/@google/genai@^1.35.0"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="module">
    import { h, render } from 'https://esm.sh/preact';
    import { useState, useEffect, useRef, useMemo } from 'https://esm.sh/preact/hooks';
    import htm from 'https://esm.sh/htm';

    const html = htm.bind(h);

    // --- Core Constants ---
    const GRID_SIZE = 24;
    const TILE_SIZE = 40;
    const MAX_PUSH = 12;

    const TileType = {
      AIR: 'AIR', DUST: 'DUST', TORCH: 'TORCH', REPEATER: 'REPEATER',
      LEVER: 'LEVER', BUTTON: 'BUTTON', LAMP: 'LAMP', BLOCK: 'BLOCK',
      GLASS: 'GLASS', SLIME: 'SLIME', PISTON: 'PISTON', STICKY_PISTON: 'STICKY_PISTON',
      PISTON_HEAD: 'PISTON_HEAD', OBSERVER: 'OBSERVER', NOTE_BLOCK: 'NOTE_BLOCK',
      REDSTONE_BLOCK: 'REDSTONE_BLOCK', COMPARATOR: 'COMPARATOR', TNT: 'TNT', 
      TARGET: 'TARGET', OBSIDIAN: 'OBSIDIAN', DAYLIGHT_SENSOR: 'DAYLIGHT_SENSOR',
      PRESSURE_PLATE: 'PRESSURE_PLATE', COUNTER: 'COUNTER'
    };

    // --- SVG Sprite Components ---
    const Sprite = ({ type, active, power, direction, mode, inverted, value }) => {
      const rot = { N: 0, E: 90, S: 180, W: 270 }[direction] || 0;
      const glowClass = active || power > 0 ? 'redstone-glow' : '';
      const color = active || power > 0 ? '#ff4d4d' : '#4a0404';

      switch (type) {
        case TileType.DUST:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full ${glowClass}">
              <path d="M18 18h4v4h-4zM10 19h20v2H10zM19 10h2v20h-2z" fill="${color}" />
            </svg>`;
        case TileType.TORCH:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full" style="transform: rotate(${rot}deg)">
              <rect x="18" y="20" width="4" height="12" fill="#5c4033" />
              <rect x="16" y="10" width="8" height="10" fill="${active ? '#ff4d4d' : '#3d0a0a'}" class="${active ? 'redstone-glow' : ''}" />
            </svg>`;
        case TileType.REPEATER:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full" style="transform: rotate(${rot}deg)">
              <rect x="4" y="4" width="32" height="32" fill="#7a7a7a" rx="2" />
              <rect x="12" y="10" width="4" height="6" fill="${active ? '#ff4d4d' : '#3d0a0a'}" />
              <rect x="24" y="10" width="4" height="6" fill="${active ? '#ff4d4d' : '#3d0a0a'}" />
              <path d="M18 28l4-8 4 8h-8z" fill="#444" />
            </svg>`;
        case TileType.LEVER:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full">
              <rect x="10" y="28" width="20" height="4" fill="#555" />
              <rect x="18" y="10" width="4" height="20" fill="#333" style="transform-origin: 20px 30px; transform: rotate(${active ? 45 : -45}deg)" />
            </svg>`;
        case TileType.LAMP:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full">
              <rect x="4" y="4" width="32" height="32" fill="${active ? '#fff3ad' : '#2d2d2d'}" rx="2" />
              <rect x="8" y="8" width="24" height="24" fill="none" stroke="${active ? '#ffcc00' : '#444'}" stroke-width="2" />
            </svg>`;
        case TileType.PISTON:
        case TileType.STICKY_PISTON:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full" style="transform: rotate(${rot}deg)">
              <rect x="4" y="14" width="32" height="22" fill="#555" />
              <rect x="4" y="4" width="32" height="10" fill="${type === TileType.STICKY_PISTON ? '#4ade80' : '#b45309'}" />
            </svg>`;
        case TileType.DAYLIGHT_SENSOR:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full">
              <rect x="4" y="4" width="32" height="32" fill="${inverted ? '#1e3a8a' : '#3b82f6'}" rx="2" />
              <rect x="12" y="12" width="16" height="16" fill="${inverted ? '#a5b4fc' : '#fde047'}" rx="8" />
              <text x="50%" y="85%" text-anchor="middle" fill="white" font-size="8" font-family="monospace">${inverted ? 'NIGHT' : 'DAY'}</text>
            </svg>`;
        case TileType.COUNTER:
          return html`
            <svg viewBox="0 0 40 40" class="w-full h-full">
              <rect x="4" y="4" width="32" height="32" fill="#1e293b" rx="4" />
              <text x="50%" y="65%" text-anchor="middle" fill="${power > 0 ? '#ff4d4d' : '#444'}" font-size="20" font-weight="bold" class="${power > 0 ? 'redstone-glow' : ''}">${value}</text>
            </svg>`;
        case TileType.BLOCK:
          return html`<div class="w-full h-full ${power > 0 ? 'bg-red-700' : 'bg-gray-600'} border border-gray-800 shadow-inner" />`;
        case TileType.REDSTONE_BLOCK:
          return html`<div class="w-full h-full bg-red-600 border-2 border-red-800 shadow-[inset_0_0_10px_rgba(0,0,0,0.5)] redstone-glow" />`;
        default:
          return html`<div class="w-full h-full border border-white/5" />`;
      }
    };

    // --- Audio System ---
    let _audioCtx = null;
    const playClick = (isOn) => {
      if (!_audioCtx) _audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = _audioCtx.createOscillator();
      const gain = _audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(isOn ? 1200 : 800, _audioCtx.currentTime);
      gain.gain.setValueAtTime(0.05, _audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, _audioCtx.currentTime + 0.1);
      osc.connect(gain).connect(_audioCtx.destination);
      osc.start(); osc.stop(_audioCtx.currentTime + 0.1);
    };

    // --- Redstone Simulation Engine ---
    const getNeighbors = (x, y) => [
      { x, y: y - 1, dir: 'N' }, { x, y: y + 1, dir: 'S' },
      { x: x - 1, y, dir: 'W' }, { x: x + 1, y, dir: 'E' }
    ];

    const getOpposite = (dir) => ({ N: 'S', S: 'N', E: 'W', W: 'E' }[dir]);

    const updateSimulation = (grid, dayTime) => {
      let nextGrid = {};
      const keys = Object.keys(grid);

      // PASS 1: Intrinsic Sources & Timers
      keys.forEach(key => {
        const tile = grid[key];
        const [x, y] = key.split(',').map(Number);
        let power = 0, active = tile.active, extra = {};

        if (tile.type === TileType.REDSTONE_BLOCK) { power = 15; active = true; }
        else if (tile.type === TileType.LEVER) power = tile.active ? 15 : 0;
        else if (tile.type === TileType.COUNTER) {
          const nextVal = ((tile.internalCounter || 0) % 15) + 1;
          power = nextVal;
          extra = { internalCounter: nextVal };
        }
        else if (tile.type === TileType.DAYLIGHT_SENSOR) {
          // dayTime is 0-2400. 0-1200 is Day.
          const isDay = dayTime < 1200;
          const peak = isDay ? 600 : 1800;
          const dist = Math.abs(dayTime - peak);
          const raw = Math.max(0, 15 - Math.floor(dist / 40));
          
          if (tile.isInverted) { // Night Mode
            power = !isDay ? raw : 0;
          } else { // Day Mode
            power = isDay ? raw : 0;
          }
          active = power > 0;
        }
        else if (tile.type === TileType.TORCH) {
          const opp = getOpposite(tile.direction);
          const vec = { N: {dx:0, dy:-1}, S: {dx:0, dy:1}, E: {dx:1, dy:0}, W: {dx:-1, dy:0} }[opp];
          const parent = grid[`${x + vec.dx},${y + vec.dy}`];
          active = !(parent && parent.power > 0);
          power = active ? 15 : 0;
        }
        else if (tile.type === TileType.REPEATER) {
          const back = getOpposite(tile.direction);
          const bVec = { N: {dx:0, dy:-1}, S: {dx:0, dy:1}, E: {dx:1, dy:0}, W: {dx:-1, dy:0} }[back];
          const input = grid[`${x + bVec.dx},${y + bVec.dy}`];
          const inputOn = input && input.power > 0;
          
          let cd = tile.tickCooldown || 0, pend = tile.pendingActive ?? tile.active, state = tile.active;
          if (inputOn !== pend) { pend = inputOn; cd = tile.delay || 1; }
          if (cd > 0) { cd--; if (cd === 0) state = pend; }
          active = state; power = active ? 15 : 0; extra = { tickCooldown: cd, pendingActive: pend };
        }

        nextGrid[key] = { ...tile, power, active, ...extra };
      });

      // PASS 2: Redstone Dust Propagation (BFS)
      const powerMap = {};
      const queue = [];
      Object.keys(nextGrid).forEach(k => {
        if (nextGrid[k].power > 0 && nextGrid[k].type !== TileType.DUST) {
          powerMap[k] = nextGrid[k].power;
          queue.push({ k, p: nextGrid[k].power });
        }
      });

      let head = 0;
      while (head < queue.length) {
        const { k, p } = queue[head++];
        const [x, y] = k.split(',').map(Number);
        getNeighbors(x, y).forEach(n => {
          const nk = `${n.x},${n.y}`;
          if (nextGrid[nk]?.type === TileType.DUST) {
            const np = Math.max(0, p - 1);
            if (np > (powerMap[nk] || 0)) {
              powerMap[nk] = np;
              queue.push({ k: nk, p: np });
            }
          }
        });
      }

      // PASS 3: Consumers (Lamps, Pistons)
      const finalGrid = { ...nextGrid };
      Object.keys(finalGrid).forEach(k => {
        const t = finalGrid[k];
        if (t.type === TileType.DUST) t.power = powerMap[k] || 0;
        
        if (t.type === TileType.LAMP) {
          const [x, y] = k.split(',').map(Number);
          t.active = getNeighbors(x, y).some(n => (powerMap[`${n.x},${n.y}`] || finalGrid[`${n.x},${n.y}`]?.power || 0) > 0);
        }
      });

      return finalGrid;
    };

    // --- Main App Component ---
    const App = () => {
      const [grid, setGrid] = useState({});
      const [tool, setTool] = useState('BUILD');
      const [selected, setSelected] = useState(TileType.DUST);
      const [direction, setDirection] = useState('N');
      const [dayTime, setDayTime] = useState(600);
      const [isPaused, setIsPaused] = useState(false);
      const [dragged, setDragged] = useState(null);
      const [hovered, setHovered] = useState(null);
      const [showSettings, setShowSettings] = useState(false);
      const [isMouseDown, setIsMouseDown] = useState(false);

      // Simulation Loop
      useEffect(() => {
        if (isPaused) return;
        const id = setInterval(() => {
          setDayTime(t => (t + 1) % 2400);
          setGrid(g => updateSimulation(g, dayTime));
        }, 100);
        return () => clearInterval(id);
      }, [isPaused, dayTime]);

      // Global Shortcuts
      useEffect(() => {
        const handle = (e) => {
          if (e.key === '1') setTool('CURSOR');
          if (e.key === '2') setTool('BUILD');
          if (e.key === '3') setTool('DELETE');
          if (e.key === '4') setTool('MOVE');
        };
        window.addEventListener('keydown', handle);
        window.addEventListener('mouseup', () => { setIsMouseDown(false); setDragged(null); });
        return () => window.removeEventListener('keydown', handle);
      }, []);

      const getSkyColor = () => {
        const isDay = dayTime < 1200;
        const factor = Math.sin(Math.PI * dayTime / 1200);
        if (isDay) return `rgb(${10 + 40*factor}, ${20 + 60*factor}, ${40 + 100*factor})`;
        const nFactor = Math.sin(Math.PI * (dayTime-1200) / 1200);
        return `rgb(${5 + 5*nFactor}, ${5 + 10*nFactor}, ${10 + 20*nFactor})`;
      };

      const handleCellDown = (e, x, y) => {
        if (e.button !== 0) return;
        setIsMouseDown(true);
        const k = `${x},${y}`;
        if (tool === 'BUILD') {
          setGrid(g => ({ ...g, [k]: { type: selected, power: 0, active: false, direction, internalCounter: 0, isInverted: false } }));
          playClick(true);
        } else if (tool === 'DELETE') {
          setGrid(g => { const n = { ...g }; delete n[k]; return n; });
        } else if (tool === 'CURSOR') {
          const t = grid[k];
          if (t?.type === TileType.LEVER) {
            setGrid(g => ({ ...g, [k]: { ...t, active: !t.active } }));
            playClick(!t.active);
          }
        } else if (tool === 'MOVE' && grid[k]) {
          setDragged(k);
        }
      };

      const handleCellEnter = (x, y) => {
        setHovered(`${x},${y}`);
        if (isMouseDown) {
          if (tool === 'BUILD') handleCellDown({ button: 0 }, x, y);
          if (tool === 'DELETE') handleCellDown({ button: 0 }, x, y);
        }
      };

      const handleCellUp = (x, y) => {
        if (tool === 'MOVE' && dragged) {
          const tk = `${x},${y}`;
          if (dragged !== tk) {
            setGrid(g => {
              const n = { ...g };
              n[tk] = n[dragged];
              delete n[dragged];
              return n;
            });
            playClick(true);
          }
        }
        setDragged(null);
      };

      const handleCellRight = (e, x, y) => {
        e.preventDefault();
        const k = `${x},${y}`;
        const t = grid[k];
        if (t?.type === TileType.DAYLIGHT_SENSOR) {
          setGrid(g => ({ ...g, [k]: { ...t, isInverted: !t.isInverted } }));
          playClick(true);
        } else if (t) {
          const nextDir = { N: 'E', E: 'S', S: 'W', W: 'N' }[t.direction];
          setGrid(g => ({ ...g, [k]: { ...t, direction: nextDir } }));
        } else {
          setDirection(d => ({ N: 'E', E: 'S', S: 'W', W: 'N' }[d]));
        }
      };

      return html`
        <div class="flex h-screen w-screen transition-colors duration-1000" style="background-color: ${getSkyColor()}">
          <!-- Sidebar -->
          <div class="w-80 bg-black/80 backdrop-blur-md border-r border-white/10 flex flex-col p-6 z-20 shadow-2xl overflow-y-auto custom-scroll">
            <h1 class="text-3xl font-bold mb-8 text-red-500 flex items-center gap-3">
              <div class="w-4 h-4 bg-red-600 rounded-full animate-pulse shadow-[0_0_12px_red]" />
              REDSTONE LAB
            </h1>

            <div class="space-y-8">
              <section>
                <div class="flex justify-between items-end mb-4">
                  <h3 class="text-xs uppercase font-bold text-slate-500 tracking-widest">Tool Palette</h3>
                  <span class="text-[10px] text-slate-700">[1-4]</span>
                </div>
                <div class="grid grid-cols-2 gap-2">
                  ${['CURSOR', 'BUILD', 'DELETE', 'MOVE'].map(m => html`
                    <button onclick=${() => setTool(m)} 
                      class="p-2 rounded font-bold text-[11px] uppercase border transition-all ${tool === m ? 'bg-red-600 border-red-400 text-white shadow-lg scale-95' : 'bg-white/5 border-white/10 text-slate-400 hover:bg-white/10'}">
                      ${m}
                    </button>
                  `)}
                </div>
              </section>

              ${tool === 'BUILD' && html`
                <section>
                  <h3 class="text-xs uppercase font-bold text-slate-500 mb-4 tracking-widest">Components</h3>
                  <div class="grid grid-cols-3 gap-2">
                    ${Object.keys(TileType).filter(k => k !== 'AIR' && k !== 'PISTON_HEAD').map(k => html`
                      <button onclick=${() => setSelected(TileType[k])} 
                        class="p-2 rounded-lg border flex flex-col items-center gap-2 transition-all ${selected === TileType[k] ? 'bg-red-900/40 border-red-500' : 'bg-white/5 border-transparent hover:border-white/20'}">
                        <div class="w-8 h-8">${ICONS[TileType[k]] || html`<${Sprite} type=${TileType[k]} active=${true} direction="N" />`}</div>
                        <span class="text-[9px] uppercase font-bold truncate w-full text-center opacity-70">${k.replace('_', ' ')}</span>
                      </button>
                    `)}
                  </div>
                </section>
              `}

              <section>
                <h3 class="text-xs uppercase font-bold text-slate-500 mb-4 tracking-widest">Lab World</h3>
                <div class="bg-white/5 p-4 rounded-xl border border-white/10">
                   <div class="flex items-center justify-between text-[11px] font-bold uppercase mb-3">
                      <span>${dayTime < 1200 ? '‚òÄÔ∏è Day' : 'üåô Night'}</span>
                      <span class="text-slate-400">${Math.floor(dayTime/100)}:00</span>
                   </div>
                   <div class="w-full h-1.5 bg-white/10 rounded-full overflow-hidden">
                      <div class="h-full bg-red-500 transition-all duration-300" style="width: ${(dayTime / 2400) * 100}%" />
                   </div>
                </div>
              </section>

              <section class="pt-4 border-t border-white/10">
                <button onclick=${() => setIsPaused(!isPaused)} 
                  class="w-full py-3 rounded-lg font-bold text-xs uppercase tracking-widest transition-colors ${isPaused ? 'bg-green-600 hover:bg-green-500' : 'bg-amber-600 hover:bg-amber-500'}">
                  ${isPaused ? '‚ñ∂ Resume Simulation' : '‚è∏ Pause Simulation'}
                </button>
              </section>
            </div>
          </div>

          <!-- Grid Area -->
          <div class="flex-1 relative overflow-auto flex items-center justify-center p-12 custom-scroll">
            <div class="grid-bg shadow-[0_0_100px_rgba(0,0,0,0.8)] relative" 
                 style="display: grid; grid-template-columns: repeat(${GRID_SIZE}, ${TILE_SIZE}px); width: ${GRID_SIZE * TILE_SIZE}px; height: ${GRID_SIZE * TILE_SIZE}px;">
              ${Array.from({ length: GRID_SIZE * GRID_SIZE }).map((_, i) => {
                const x = i % GRID_SIZE, y = Math.floor(i / GRID_SIZE);
                const k = `${x},${y}`;
                const t = grid[k];
                const isDragSrc = dragged === k;
                const isDragTarget = hovered === k && dragged;

                return html`
                  <div key=${k} 
                    onmousedown=${(e) => handleCellDown(e, x, y)}
                    onmouseenter=${() => handleCellEnter(x, y)}
                    onmouseup=${() => handleCellUp(x, y)}
                    oncontextmenu=${(e) => handleCellRight(e, x, y)}
                    class="box-border border border-white/5 flex items-center justify-center relative transition-all ${isDragTarget ? 'bg-white/10 scale-110 z-10' : ''} ${isDragSrc ? 'opacity-20' : ''}"
                    style="width: ${TILE_SIZE}px; height: ${TILE_SIZE}px;">
                    ${t && html`<${Sprite} type=${t.type} active=${t.active} power=${t.power} direction=${t.direction} inverted=${t.isInverted} value=${t.internalCounter} />`}
                    ${hovered === k && tool === 'BUILD' && !t && html`<div class="opacity-30 pointer-events-none w-full h-full scale-75"><${Sprite} type=${selected} active=${false} direction=${direction} /></div>`}
                  </div>
                `;
              })}
            </div>
            
            <!-- HUD -->
            <div class="fixed top-6 right-6 flex gap-3">
              <div class="bg-black/80 px-4 py-2 rounded-lg border border-white/10 text-[11px] font-bold uppercase tracking-widest">
                Tool: <span class="text-red-500">${tool}</span>
              </div>
              <div class="bg-black/80 px-4 py-2 rounded-lg border border-white/10 text-[11px] font-bold uppercase tracking-widest">
                FPS: 10
              </div>
            </div>
          </div>
        </div>
      `;
    };

    render(html`<${App} />`, document.getElementById('root'));
  </script>
</body>
</html>